<!doctype html><html lang="ja"><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Bluesongs Player</title>
<style>
html,body{margin:0;padding:0;background:#000;color:#ddd;font-family:-apple-system,system-ui,sans-serif}
.wrap{max-width:980px;margin:0 auto;padding:12px}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
button,label,input{
  background:#111;color:#ddd;border:1px solid #333;border-radius:10px;
  padding:10px 12px;font-size:16px
}
button:disabled{opacity:.45}
input[type=file]{display:none}
input[type=text]{min-width:220px;flex:1}
small{opacity:.8}
video,audio{width:100%;margin-top:10px;background:#000}
#status{margin-top:8px;font-size:14px;opacity:.85}
#plist{
  list-style:none;padding:0;margin:10px 0 0 0;border:1px solid #222;border-radius:10px;overflow:auto;
  max-height: 45vh;
}
#plist li{padding:10px 12px;border-top:1px solid #222;word-break:break-all}
#plist li:first-child{border-top:none}
#plist li.curr{background:#1b1b1b}
#plist li.hidden{display:none}
#plist li:active{transform:scale(.995)}
.pills{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
.speed button{padding:8px 10px;font-size:14px}
.speed .on{border-color:#777}
.badge{opacity:.85}

/* 操作ボタンをいい感じに並べる */
.ctrl button{flex:1; min-width:120px}

/* ジャバラ（折りたたみ） */
details.ctrlpanel{
  border:1px solid #222; border-radius:12px; padding:10px; background:#070707;
}
details.ctrlpanel > summary{
  cursor:pointer; list-style:none; user-select:none;
  background:#111; border:1px solid #333; border-radius:10px;
  padding:10px 12px; font-size:16px;
}
details.ctrlpanel > summary::-webkit-details-marker{display:none;}
details.ctrlpanel[open]{padding-bottom:12px;}
</style></head><body>
<div class="wrap">

  <!-- 折りたたみ：再生/停止の行より上全部 -->
  <details id="panel" class="ctrlpanel">
    <summary>設定（タップで開閉）</summary>

    <div class="row" style="margin-top:10px">
      <label>ファイル選択（複数OK）
        <input id="pickFiles" type="file" multiple
          accept=".mp4,.m4v,.mov,.mp3,.m4a,video/*,audio/*">
      </label>
      <label>フォルダ選択
        <input id="pickFolder" type="file" multiple webkitdirectory directory
          accept=".mp4,.m4v,.mov,.mp3,.m4a">
      </label>
    </div>

    <div class="row" style="margin-top:10px">
      <input id="filter" type="text" placeholder="検索（この結果だけ再生/シャッフル対象）例: 12 / intro / .mp3" />
      <button id="clearFilter">クリア</button>

      <span class="pills">
        <label><input id="shuffle" type="checkbox"> シャッフル</label>

        <!-- ループを2種類に分離 -->
        <label><input id="loop" type="checkbox"> ループ（キュー）</label>
        <label><input id="loopone" type="checkbox"> 1曲ループ</label>

        <label><input id="autonext" type="checkbox" checked> 連続再生</label>
        <label><input id="sortPath" type="checkbox" checked> フォルダ順で整列</label>
        <label><input id="follow" type="checkbox" checked> 再生中へ追従</label>
        <span class="badge" id="hitBadge"></span>
      </span>
    </div>

    <div class="row speed" style="margin-top:10px">
      再生速度：
      <button class="spd" data-rate="0.75">0.75</button>
      <button class="spd" data-rate="1">1.0</button>
      <button class="spd" data-rate="1.25">1.25</button>
      <button class="spd" data-rate="1.5">1.5</button>
      <button class="spd" data-rate="2">2.0</button>
    </div>
  </details>

  <!-- 操作ボタン：順番（再生→PiP→前へ→次へ） -->
  <div class="row ctrl" style="margin-top:10px">
    <button id="play" disabled>再生/停止</button>
    <button id="pip"  disabled>PiP（動画）</button>
    <button id="prev" disabled>前へ</button>
    <button id="next" disabled>次へ</button>
  </div>

  <div id="status">未選択</div>

  <video id="vid" controls playsinline style="display:none"></video>
  <audio id="aud" controls style="display:none"></audio>

  <ul id="plist"></ul>
  <small>
    ※ファイル選択直後は自動再生しません（再生ボタンで開始）。リストから選ぶと即再生します。<br>
    ※検索でヒットした曲だけが「次へ/シャッフル/ループ（キュー）」の対象。検索を消すと全曲に戻る。<br>
    ※「連続再生OFF」なら曲が終わっても次へ進みません。<br>
    ※「1曲ループ」は media要素のloop機能で安定動作します。<br>
    ※ホーム画面アプリ化（standalone）ではPiPが制限されることがあります。PiPしたい時はSafariで同じURLを開いてください。
  </small>
</div>

<script>
(() => {
  const panel = document.getElementById('panel');

  const status = document.getElementById('status');
  const plist  = document.getElementById('plist');
  const hitBadge = document.getElementById('hitBadge');

  const pickFiles  = document.getElementById('pickFiles');
  const pickFolder = document.getElementById('pickFolder');

  const btnPlay = document.getElementById('play');
  const btnPrev = document.getElementById('prev');
  const btnNext = document.getElementById('next');
  const btnPiP  = document.getElementById('pip');

  const chkShuffle = document.getElementById('shuffle');
  const chkLoop    = document.getElementById('loop');
  const chkLoopOne = document.getElementById('loopone');
  const chkAutoNext= document.getElementById('autonext');
  const chkSortPath= document.getElementById('sortPath');
  const chkFollow  = document.getElementById('follow');

  const filterInput = document.getElementById('filter');
  const clearFilter = document.getElementById('clearFilter');

  const vid = document.getElementById('vid');
  const aud = document.getElementById('aud');

  let files = [];
  let order = [];
  let pos = -1;
  let url = null;
  let nowIndex = null;
  let playbackRate = 1.0;

  const extsOK = new Set(['mp4','m4v','mov','mp3','m4a']);
  const videoExts = new Set(['mp4','m4v','mov']);

  // ★ホーム画面アプリ（standalone）判定
  function isStandalone() {
    return (window.navigator.standalone === true) ||
           (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches);
  }

  function closePanelOnPlay(){
    if (panel) panel.open = false;
  }

  // どの方法で再生が始まっても閉じる（プレイヤーの▶︎でもOK）
  const closePanelOnAnyPlay = () => closePanelOnPlay();
  vid.addEventListener('play', closePanelOnAnyPlay);
  aud.addEventListener('play', closePanelOnAnyPlay);
  vid.addEventListener('playing', closePanelOnAnyPlay);
  aud.addEventListener('playing', closePanelOnAnyPlay);

  function revoke(){ if(url){ URL.revokeObjectURL(url); url=null; } }
  function extOf(name){
    const m = (name||'').toLowerCase().match(/\.([a-z0-9]+)$/);
    return m ? m[1] : '';
  }
  function enabledBase(on){ btnPlay.disabled = !on; }

  function keyOf(f){
    const rp = (chkSortPath.checked && f.webkitRelativePath) ? f.webkitRelativePath : f.name;
    return (rp || '').toLowerCase();
  }

  function naturalCompare(a, b){
    try{
      return a.localeCompare(b, 'ja', { numeric: true, sensitivity: 'base' });
    }catch(_){
      const re = /(\d+)|(\D+)/g;
      const ax = a.match(re) || [];
      const bx = b.match(re) || [];
      const n = Math.min(ax.length, bx.length);
      for(let i=0;i<n;i++){
        const as = ax[i], bs = bx[i];
        const an = /^\d+$/.test(as), bn = /^\d+$/.test(bs);
        if (an && bn){
          const ai = parseInt(as,10), bi = parseInt(bs,10);
          if (ai !== bi) return ai - bi;
          if (as.length !== bs.length) return as.length - bs.length;
        } else {
          if (as !== bs) return as < bs ? -1 : 1;
        }
      }
      return ax.length - bx.length;
    }
  }

  function sortFilesStable(list){
    return list.slice().sort((fa, fb) => naturalCompare(keyOf(fa), keyOf(fb)));
  }

  function shuffleArray(a){
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }

  function setSpeed(rate){
    playbackRate = rate;
    if (vid.style.display !== 'none') vid.playbackRate = rate;
    if (aud.style.display !== 'none') aud.playbackRate = rate;
    document.querySelectorAll('.spd').forEach(b=>{
      b.classList.toggle('on', Number(b.dataset.rate) === rate);
    });
  }

  // 1曲ループをmedia要素へ反映（安定版）
  function applyLoopOneToPlayers(){
    vid.loop = chkLoopOne.checked;
    aud.loop = chkLoopOne.checked;
  }

  // ループの排他（どちらか片方だけ）＋反映
  chkLoopOne.addEventListener('change', () => {
    if (chkLoopOne.checked) chkLoop.checked = false;
    applyLoopOneToPlayers();
  });
  chkLoop.addEventListener('change', () => {
    if (chkLoop.checked) chkLoopOne.checked = false;
    applyLoopOneToPlayers();
  });
  applyLoopOneToPlayers();

  function showPlayerFor(ext){
    const isVideo = videoExts.has(ext);
    vid.style.display = isVideo ? '' : 'none';
    aud.style.display = isVideo ? 'none' : '';
    if (isVideo) aud.pause(); else vid.pause();

    const player = isVideo ? vid : aud;
    player.playbackRate = playbackRate;

    // 曲切替時もloop状態を確実に反映
    applyLoopOneToPlayers();

    // ★PiPはstandaloneでは案内運用にする（ボタンは押せるようにしておく）
    if (!isVideo) {
      btnPiP.disabled = true;           // 音声はPiPなし
      btnPiP.textContent = 'PiP（動画）';
      return player;
    }

    if (isStandalone()) {
      // standaloneではOS制限で失敗しやすいので“案内ボタン”として活かす
      btnPiP.disabled = false;
      btnPiP.textContent = 'PiP（Safari）';
      return player;
    }

    // Safari通常タブなら従来どおり判定
    const pipCapable = (
      (document.pictureInPictureEnabled && typeof vid.requestPictureInPicture === 'function') ||
      (typeof vid.webkitSetPresentationMode === 'function')
    );
    btnPiP.disabled = !pipCapable;
    btnPiP.textContent = 'PiP（動画）';

    return player;
  }

  function rebuildQueue(){
    const q = (filterInput.value || '').trim().toLowerCase();

    let base = [];
    if (!q){
      base = Array.from({length: files.length}, (_,i)=>i);
    } else {
      for (let i=0;i<files.length;i++){
        const label = (files[i].webkitRelativePath ? files[i].webkitRelativePath : files[i].name).toLowerCase();
        if (label.includes(q)) base.push(i);
      }
    }

    if (chkShuffle.checked) shuffleArray(base);

    order = base;
    pos = (nowIndex != null) ? order.indexOf(nowIndex) : -1;

    const hasQueue = order.length > 0;
    btnPrev.disabled = !hasQueue;
    btnNext.disabled = !hasQueue;

    updateStatus();
    applyFilterUI();
  }

  function updateStatus(){
    const q = (filterInput.value || '').trim();
    const hitCount = order.length;
    hitBadge.textContent = q ? `検索ヒット: ${hitCount}件` : `全曲: ${hitCount}件`;

    if (nowIndex == null){
      status.textContent = '未選択';
      return;
    }

    if (pos >= 0){
      status.textContent = `${pos+1}/${order.length} : ${files[nowIndex].name}`;
    } else {
      status.textContent = `準備中（キュー外）: ${files[nowIndex].name}  |  キュー: ${order.length}件`;
    }
  }

  function highlightCurrent(allowScroll){
    const lis = plist.querySelectorAll('li');
    lis.forEach(li=>li.classList.remove('curr'));
    if (nowIndex == null) return;

    const li = lis[nowIndex];
    if (!li) return;
    li.classList.add('curr');

    if (allowScroll && chkFollow.checked && !li.classList.contains('hidden')){
      li.scrollIntoView({ block: 'nearest' });
    }
  }

  function applyFilterUI(){
    const inSet = new Set(order);
    const lis = plist.querySelectorAll('li');

    lis.forEach(li => {
      const i = Number(li.dataset.i);
      const keepNow = (nowIndex != null && i === nowIndex);
      const show = inSet.has(i) || keepNow;
      li.classList.toggle('hidden', !show);
    });

    highlightCurrent(true);
  }

  function renderList(){
    plist.innerHTML = '';
    files.forEach((f,i)=>{
      const li = document.createElement('li');
      li.textContent = f.webkitRelativePath ? f.webkitRelativePath : f.name;
      li.dataset.i = String(i);
      li.addEventListener('click', ()=> selectAndPlay(i));
      plist.appendChild(li);
    });
    applyFilterUI();
  }

  function prepareIndex(fileIndex){
    if (fileIndex == null || fileIndex < 0 || fileIndex >= files.length) return;

    nowIndex = fileIndex;
    pos = order.indexOf(nowIndex);

    const f = files[nowIndex];
    const ext = extOf(f.name);

    revoke();
    url = URL.createObjectURL(f);

    const player = showPlayerFor(ext);
    player.src = url;

    updateStatus();
    applyFilterUI();
  }

  function playNow(){
    if (nowIndex == null) return;
    closePanelOnPlay();
    const ext = extOf(files[nowIndex].name);
    const player = videoExts.has(ext) ? vid : aud;
    player.play().catch(()=>{});
  }

  // --- PiPまわり：Mac Safariで「次へ」に行くとPiPが拡大/崩れる対策（手動操作時だけ） ---
  const UA = navigator.userAgent || '';
  function isMacDesktop(){
    // iPhone/iPadは "Mobile" が入る。macOS Safariは入らない。
    return /Macintosh/.test(UA) && !/Mobile/.test(UA);
  }

  function hasWebkitPiP(){
    return (typeof vid.webkitSetPresentationMode === 'function');
  }
  function isPiPActive(){
    return (document.pictureInPictureElement === vid) ||
           (hasWebkitPiP() && vid.webkitPresentationMode === 'picture-in-picture');
  }
  function tryExitPiP(){
    try{
      // Safariはwebkit系が同期的に効くことが多い
      if (hasWebkitPiP() && vid.webkitPresentationMode === 'picture-in-picture'){
        vid.webkitSetPresentationMode('inline');
        return true;
      }
      if (document.pictureInPictureElement){
        document.exitPictureInPicture?.().catch(()=>{});
        return true;
      }
    }catch(_){}
    return false;
  }
  function tryEnterPiP(){
    // iPhoneホーム画面版は案内運用なのでここでは触らない
    if (isStandalone()) return false;
    // 動画以外は対象外
    if (vid.style.display === 'none') return false;

    try{
      // Safariはwebkit系を優先（同期的に動きやすい）
      if (hasWebkitPiP()){
        vid.webkitSetPresentationMode('picture-in-picture');
        return true;
      }
      if (document.pictureInPictureEnabled && vid.requestPictureInPicture){
        vid.requestPictureInPicture().catch(()=>{});
        return true;
      }
    }catch(_){}
    return false;
  }

  // リストタップで「選択→即再生」したい（ファイル選択直後は自動再生しないまま）

  // リストタップで「選択→即再生」したい（ファイル選択直後は自動再生しないまま）
  function selectAndPlay(i){
    const wasPiP = isPiPActive();

    // macOS Safariだけ：PiP表示が拡大/崩れるのを避けるため、一度PiPを抜けて入り直す
    if (wasPiP && isMacDesktop()) tryExitPiP();

    prepareIndex(i);
    playNow();

    // macOS Safariだけ：PiPに戻す（iPhone/iPadはPiP継続を優先して触らない）
    if (wasPiP && isMacDesktop()){
      tryEnterPiP();
      const once = () => {
        vid.removeEventListener('playing', once);
        if (!isPiPActive()) tryEnterPiP();
      };
      vid.addEventListener('playing', once);
    }
  }

  }
  function next(){
    if (!order.length) return;

    const wasPiP = isPiPActive();
    if (wasPiP && isMacDesktop()) tryExitPiP();

    if (pos < 0){
      prepareIndex(order[0]); playNow(); return;
    }
    if (pos+1 < order.length){ prepareIndex(order[pos+1]); playNow(); }
    else if (chkLoop.checked){ prepareIndex(order[0]); playNow(); }

    if (wasPiP && isMacDesktop()){
      tryEnterPiP();
      const once = () => {
        vid.removeEventListener('playing', once);
        if (!isPiPActive()) tryEnterPiP();
      };
      vid.addEventListener('playing', once);
    }
  }

    if (wasPiP){
      tryEnterPiP();
      const once = () => {
        vid.removeEventListener('playing', once);
        if (!isPiPActive()) tryEnterPiP();
      };
      vid.addEventListener('playing', once);
    }
  }
  function prev(){
    if (!order.length) return;

    const wasPiP = isPiPActive();
    if (wasPiP && isMacDesktop()) tryExitPiP();

    if (pos < 0){
      prepareIndex(order[0]); playNow(); return;
    }
    if (pos-1 >= 0){ prepareIndex(order[pos-1]); playNow(); }
    else if (chkLoop.checked){ prepareIndex(order[order.length-1]); playNow(); }

    if (wasPiP && isMacDesktop()){
      tryEnterPiP();
      const once = () => {
        vid.removeEventListener('playing', once);
        if (!isPiPActive()) tryEnterPiP();
      };
      vid.addEventListener('playing', once);
    }
  }

    if (wasPiP){
      tryEnterPiP();
      const once = () => {
        vid.removeEventListener('playing', once);
        if (!isPiPActive()) tryEnterPiP();
      };
      vid.addEventListener('playing', once);
    }
  }

  function onEnded(){
    if (chkLoopOne.checked) return;
    if (chkAutoNext.checked) next();
  }

  vid.addEventListener('ended', onEnded);
  aud.addEventListener('ended', onEnded);

  btnPlay.addEventListener('click', ()=>{
    if (nowIndex == null){
      if (order.length){
        prepareIndex(order[0]);
        playNow();
      }
      return;
    }
    const ext = extOf(files[nowIndex].name);
    const player = videoExts.has(ext) ? vid : aud;
    if (player.paused){ closePanelOnPlay(); player.play().catch(()=>{}); }
    else player.pause();
  });

  btnNext.addEventListener('click', next);
  btnPrev.addEventListener('click', prev);

  btnPiP.addEventListener('click', async ()=>{
    // ★ホーム画面アプリ化ではPiP制限があるので案内にする
    if (isStandalone()) {
      alert('ホーム画面アプリ版ではPiPが制限されます。\\nPiPしたい時はSafariで同じURLを開いて、そこでPiPを押してね。\\n（Safari側のブックマークから開くのが確実）');
      return;
    }

    try{
      if (document.pictureInPictureEnabled && vid.requestPictureInPicture){
        await vid.requestPictureInPicture(); return;
      }
      if (vid.webkitSetPresentationMode){
        vid.webkitSetPresentationMode('picture-in-picture'); return;
      }
      alert('この環境ではPiPが使えないみたい。');
    }catch(_){
      alert('PiP開始に失敗。再生中に押すと成功しやすいよ。');
    }
  });

  function setFiles(inputFiles){
    const arr = Array.from(inputFiles||[]);
    const ok = arr.filter(f=>{
      const ext = extOf(f.name);
      return extsOK.has(ext) || f.type.startsWith('video/') || f.type.startsWith('audio/');
    });

    files = sortFilesStable(ok);

    enabledBase(files.length>0);
    if(!files.length){
      status.textContent='対応ファイルなし（mp4/mov/m4v/mp3/m4a）';
      plist.innerHTML='';
      order = [];
      pos = -1;
      nowIndex = null;
      btnPrev.disabled = true;
      btnNext.disabled = true;
      hitBadge.textContent = '';
      return;
    }

    renderList();
    rebuildQueue();

    if (order.length){
      prepareIndex(order[0]);
    } else {
      nowIndex = null;
      status.textContent='検索ヒット 0件（条件を変えてね）';
      applyFilterUI();
    }
  }

  pickFiles.addEventListener('change', e=>setFiles(e.target.files));
  pickFolder.addEventListener('change', e=>setFiles(e.target.files));

  chkShuffle.addEventListener('change', rebuildQueue);
  chkSortPath.addEventListener('change', ()=>{
    if(!files.length) return;

    const keepName = (nowIndex != null) ? files[nowIndex].name : null;
    files = sortFilesStable(files);
    if (keepName){
      const k = files.findIndex(f => f.name === keepName);
      nowIndex = (k >= 0) ? k : nowIndex;
    }
    renderList();
    rebuildQueue();
  });

  filterInput.addEventListener('input', rebuildQueue);
  clearFilter.addEventListener('click', ()=>{ filterInput.value=''; rebuildQueue(); });

  chkFollow.addEventListener('change', ()=> highlightCurrent(true));

  // ✅ 再生速度ボタン修正版（rate未定義＆boolean渡しを解消）
  document.querySelectorAll('.spd').forEach(b=>{
    b.addEventListener('click', () => setSpeed(Number(b.dataset.rate)));
  });
  setSpeed(1.0);

  enabledBase(false);
  btnPrev.disabled = true;
  btnNext.disabled = true;
  window.addEventListener('beforeunload', revoke);
})();
</script>
</body></html>
